import { Type } from "@sinclair/typebox";

import { parseModelSpec } from "../../models/model-spec.js";
import type { ToolContext, MuaddibTool } from "./types.js";
import { toConfiguredString } from "../../utils/index.js";

export interface GenerateImageInput {
  prompt: string;
  image_urls?: string[];
}

export interface GeneratedImageResultItem {
  data: string;
  mimeType: string;
  artifactUrl: string;
}

export interface GenerateImageResult {
  summaryText: string;
  images: GeneratedImageResultItem[];
}

export type GenerateImageExecutor = (input: GenerateImageInput) => Promise<GenerateImageResult>;
import { writeArtifactBytes } from "./artifact-storage.js";

const DEFAULT_IMAGE_LIMIT = 3_500_000;
const DEFAULT_IMAGE_GEN_TIMEOUT_MS = 60_000;
const DEFAULT_OPENROUTER_BASE_URL = "https://openrouter.ai/api/v1";
const IMAGE_SUFFIX_BY_MIME_TYPE: Record<string, string> = {
  "image/png": ".png",
  "image/jpeg": ".jpg",
  "image/webp": ".webp",
  "image/gif": ".gif",
};

export function createGenerateImageTool(
  executors: { generateImage: GenerateImageExecutor },
): MuaddibTool {
  return {
    name: "generate_image",
    persistType: "artifact",
    label: "Generate Image",
    description:
      "Generate image(s) using tools.image_gen.model. Optionally include reference image URLs for edits or variations.",
    parameters: Type.Object({
      prompt: Type.String({
        description: "Text description of the image to generate.",
      }),
      image_urls: Type.Optional(
        Type.Array(Type.String({ format: "uri" }), {
          description: "Optional list of reference image URLs to include.",
        }),
      ),
    }),
    execute: async (_toolCallId, params: GenerateImageInput) => {
      const output = await executors.generateImage(params);
      return {
        content: [
          { type: "text", text: output.summaryText },
          ...output.images.map((image) => ({
            type: "image" as const,
            data: image.data,
            mimeType: image.mimeType,
          })),
        ],
        details: {
          kind: "generate_image",
          count: output.images.length,
          artifactUrls: output.images.map((image) => image.artifactUrl),
        },
      };
    },
  };
}

export function createDefaultGenerateImageExecutor(
  options: ToolContext,
): GenerateImageExecutor {

  const openRouterBaseUrl = DEFAULT_OPENROUTER_BASE_URL;
  const maxImageBytes = options.toolsConfig?.jina?.maxImageBytes ?? DEFAULT_IMAGE_LIMIT;
  const timeoutMs = options.toolsConfig?.imageGen?.timeoutMs ?? DEFAULT_IMAGE_GEN_TIMEOUT_MS;

  return async (input: GenerateImageInput): Promise<GenerateImageResult> => {
    const prompt = input.prompt.trim();
    if (!prompt) {
      throw new Error("generate_image.prompt must be non-empty.");
    }

    const configuredModel = toConfiguredString(options.toolsConfig?.imageGen?.model);
    if (!configuredModel) {
      throw new Error("generate_image tool requires tools.image_gen.model configuration.");
    }

    const modelSpec = parseModelSpec(configuredModel);
    if (modelSpec.provider !== "openrouter") {
      throw new Error(`tools.image_gen.model must use openrouter provider, got: ${modelSpec.provider}`);
    }

    const apiKey = await resolveOpenRouterApiKey(options);
    if (!apiKey) {
      throw new Error(
        "generate_image requires OpenRouter API key via providers.openrouter.key or OPENROUTER_API_KEY.",
      );
    }

    const contentBlocks: Array<Record<string, unknown>> = [{ type: "text", text: prompt }];
    const imageUrls = input.image_urls ?? [];

    for (const rawImageUrl of imageUrls) {
      const imageUrl = rawImageUrl.trim();
      if (!imageUrl) {
        throw new Error("generate_image.image_urls entries must be non-empty URLs.");
      }

      const dataUrl = await fetchImageAsDataUrl(imageUrl, maxImageBytes);
      contentBlocks.push({
        type: "image_url",
        image_url: {
          url: dataUrl,
        },
      });
    }

    const responsePayload = await callOpenRouterImageGeneration({
      baseUrl: openRouterBaseUrl,
      apiKey,
      modelId: modelSpec.modelId,
      timeoutMs,
      contentBlocks,
    });

    const dataUrls = extractGeneratedImageDataUrls(responsePayload);
    if (dataUrls.length === 0) {
      throw new Error("Image generation failed: No images generated by model.");
    }

    const images: GeneratedImageResultItem[] = [];
    for (const dataUrl of dataUrls) {
      const parsedImage = parseDataUrlImage(dataUrl);
      const imageBytes = Buffer.from(parsedImage.data, "base64");

      if (imageBytes.length > maxImageBytes) {
        throw new Error(
          `Generated image too large (${imageBytes.length} bytes). Maximum allowed: ${maxImageBytes} bytes`,
        );
      }

      const suffix = IMAGE_SUFFIX_BY_MIME_TYPE[parsedImage.mimeType.toLowerCase()] ?? ".png";
      const artifactUrl = await writeArtifactBytes(options, imageBytes, suffix);
      images.push({
        data: parsedImage.data,
        mimeType: parsedImage.mimeType,
        artifactUrl,
      });
    }

    const summaryText = images.map((entry) => `Generated image: ${entry.artifactUrl}`).join("\n");

    return {
      summaryText,
      images,
    };
  };
}

interface OpenRouterImageGenerationRequest {
  baseUrl: string;
  apiKey: string;
  modelId: string;
  timeoutMs: number;
  contentBlocks: Array<Record<string, unknown>>;
}

async function callOpenRouterImageGeneration(
  request: OpenRouterImageGenerationRequest,
): Promise<unknown> {
  const abortController = new AbortController();
  const timeoutId = setTimeout(() => {
    abortController.abort();
  }, request.timeoutMs);

  try {
    const response = await fetch(`${request.baseUrl}/chat/completions`, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${request.apiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        model: request.modelId,
        messages: [
          {
            role: "user",
            content: request.contentBlocks,
          },
        ],
        modalities: ["image", "text"],
      }),
      signal: abortController.signal,
    });

    const bodyText = (await response.text()).trim();
    const parsedBody = parseJsonResponseBody(bodyText);

    if (!response.ok) {
      const details = toResponseErrorDetail(parsedBody, bodyText);
      throw new Error(`Image generation failed: OpenRouter HTTP ${response.status}: ${details}`);
    }

    const responseError = extractErrorMessage(parsedBody);
    if (responseError) {
      throw new Error(`Image generation failed: ${responseError}`);
    }

    return parsedBody;
  } catch (error) {
    if (isAbortError(error)) {
      throw new Error(`generate_image request timed out after ${request.timeoutMs}ms.`, { cause: error });
    }
    throw error;
  } finally {
    clearTimeout(timeoutId);
  }
}

function extractGeneratedImageDataUrls(payload: unknown): string[] {
  if (!payload || typeof payload !== "object") {
    return [];
  }

  const response = payload as {
    choices?: Array<{ message?: { images?: unknown[]; content?: unknown } }>;
  };

  const dataUrls: string[] = [];

  const choices = response.choices ?? [];
  for (const choice of choices) {
    const message = choice?.message;
    if (!message || typeof message !== "object") {
      continue;
    }

    const images = Array.isArray(message.images) ? message.images : [];
    for (const imageEntry of images) {
      const url = extractImageUrlFromPayloadEntry(imageEntry);
      if (url && url.startsWith("data:")) {
        dataUrls.push(url);
      }
    }

    if (Array.isArray(message.content)) {
      for (const contentEntry of message.content) {
        if (!contentEntry || typeof contentEntry !== "object") {
          continue;
        }

        const asRecord = contentEntry as Record<string, unknown>;
        const type = asRecord.type;
        if (type !== "image_url") {
          continue;
        }

        const imageUrlPayload = asRecord.image_url;
        if (!imageUrlPayload || typeof imageUrlPayload !== "object") {
          continue;
        }

        const imageUrl = (imageUrlPayload as { url?: unknown }).url;
        if (typeof imageUrl === "string" && imageUrl.startsWith("data:")) {
          dataUrls.push(imageUrl);
        }
      }
    }
  }

  return dataUrls;
}

function extractImageUrlFromPayloadEntry(entry: unknown): string | undefined {
  if (typeof entry === "string") {
    return entry;
  }

  if (!entry || typeof entry !== "object") {
    return undefined;
  }

  const asRecord = entry as {
    url?: unknown;
    image_url?: {
      url?: unknown;
    };
  };

  if (typeof asRecord.url === "string") {
    return asRecord.url;
  }

  if (typeof asRecord.image_url?.url === "string") {
    return asRecord.image_url.url;
  }

  return undefined;
}

interface ParsedDataUrlImage {
  mimeType: string;
  data: string;
}

function parseDataUrlImage(dataUrl: string): ParsedDataUrlImage {
  const match = dataUrl.match(/^data:([^;,]+);base64,([\s\S]+)$/i);
  if (!match) {
    throw new Error("Image generation returned unsupported image payload format.");
  }

  const mimeType = match[1].trim().toLowerCase();
  const data = match[2].trim();
  if (!mimeType || !data) {
    throw new Error("Image generation returned empty image payload.");
  }

  return {
    mimeType,
    data,
  };
}

async function fetchImageAsDataUrl(
  imageUrl: string,
  maxImageBytes: number,
): Promise<string> {
  const parsedUrl = new URL(imageUrl);
  if (parsedUrl.protocol !== "http:" && parsedUrl.protocol !== "https:") {
    throw new Error(`Failed to fetch reference image ${imageUrl}: URL must use http:// or https://.`);
  }

  const response = await fetch(imageUrl, {
    headers: {
      "User-Agent": "muaddib/1.0",
    },
  });

  if (!response.ok) {
    throw new Error(`Failed to fetch reference image ${imageUrl}: HTTP ${response.status}.`);
  }

  const contentType = (response.headers.get("content-type") ?? "").split(";")[0].trim().toLowerCase();
  if (!contentType.startsWith("image/")) {
    throw new Error(
      `Failed to fetch reference image ${imageUrl}: URL is not an image (content-type: ${contentType || "unknown"}).`,
    );
  }

  const imageBytes = Buffer.from(await response.arrayBuffer());
  if (imageBytes.length > maxImageBytes) {
    throw new Error(
      `Failed to fetch reference image ${imageUrl}: Image too large (${imageBytes.length} bytes). Maximum allowed: ${maxImageBytes} bytes.`,
    );
  }

  return `data:${contentType};base64,${imageBytes.toString("base64")}`;
}

async function resolveOpenRouterApiKey(options: ToolContext): Promise<string | undefined> {
  const key = toConfiguredString(await options.authStorage.getApiKey("openrouter"));
  if (key) return key;
  return toConfiguredString(process.env.OPENROUTER_API_KEY);
}



function parseJsonResponseBody(body: string): unknown {
  if (!body) {
    return {};
  }

  try {
    return JSON.parse(body) as unknown;
  } catch {
    throw new Error(`Expected JSON response body, got: ${body.slice(0, 200)}`);
  }
}

function toResponseErrorDetail(parsedBody: unknown, rawBody: string): string {
  const fromParsed = extractErrorMessage(parsedBody);
  if (fromParsed) {
    return fromParsed;
  }

  if (rawBody) {
    return rawBody;
  }

  return "(empty response body)";
}

function extractErrorMessage(value: unknown): string | undefined {
  if (!value || typeof value !== "object") {
    return undefined;
  }

  const asRecord = value as Record<string, unknown>;
  const directError = asRecord.error;

  if (typeof directError === "string") {
    return directError;
  }

  if (directError && typeof directError === "object") {
    const message = (directError as Record<string, unknown>).message;
    if (typeof message === "string" && message.trim()) {
      return message.trim();
    }
  }

  return undefined;
}

function isAbortError(error: unknown): boolean {
  return Boolean(error && typeof error === "object" && (error as { name?: unknown }).name === "AbortError");
}
